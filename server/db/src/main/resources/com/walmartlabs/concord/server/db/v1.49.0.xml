<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.3.xsd">

    <changeSet id="1490000" author="ybrigo@gmail.com">
        <addColumn tableName="PROCESS_QUEUE">
            <column name="RUNTIME" type="varchar(64)">
                <constraints nullable="true"/>
            </column>
        </addColumn>
    </changeSet>

    <changeSet id="1490010" author="ybrigo@gmail.com">
        <createTable tableName="PROCESS_LOG_SEGMENT">
            <column name="INSTANCE_ID" type="uuid">
                <constraints nullable="false"/>
            </column>
            <column name="INSTANCE_CREATED_AT" type="timestamp">
                <constraints nullable="false" />
            </column>
            <column name="SEGMENT_NAME" type="varchar(256)">
                <constraints nullable="false"/>
            </column>
            <column name="CORRELATION_ID" type="uuid">
                <constraints nullable="false"/>
            </column>
            <column name="SEGMENT_TS" type="timestamp">
                <constraints nullable="false"/>
            </column>
            <column name="SEGMENT_ID" type="bigserial">
                <constraints nullable="false" primaryKey="true"/>
            </column>
        </createTable>
    </changeSet>

    <changeSet id="1490011" author="ybrigo@gmail.com">
        <addUniqueConstraint tableName="PROCESS_LOG_SEGMENT" columnNames="INSTANCE_ID, INSTANCE_CREATED_AT, SEGMENT_NAME, CORRELATION_ID"/>
    </changeSet>

    <changeSet id="1490020" author="ybrigo@gmail.com">
        <createTable tableName="PROCESS_LOG_DATA">
            <column name="INSTANCE_ID" type="uuid">
                <constraints nullable="false"/>
            </column>
            <column name="INSTANCE_CREATED_AT" type="timestamp">
                <constraints nullable="false"/>
            </column>
            <column name="SEGMENT_ID" type="bigserial">
                <constraints nullable="false"/>
            </column>
            <column name="LOG_RANGE" type="int4range">
                <constraints nullable="false"/>
            </column>
            <column name="SEGMENT_RANGE" type="int4range">
                <constraints nullable="false"/>
            </column>
            <column name="CHUNK_DATA" type="blob">
                <constraints nullable="false"/>
            </column>
            <column name="LOG_SEQ" type="bigserial">
                <constraints primaryKey="true" nullable="false"/>
            </column>
        </createTable>

        <addForeignKeyConstraint constraintName="FK_LOG_DATA_SEGMENT"
                                 baseTableName="PROCESS_LOG_DATA" baseColumnNames="SEGMENT_ID"
                                 referencedTableName="PROCESS_LOG_SEGMENT" referencedColumnNames="SEGMENT_ID"
                                 onDelete="CASCADE"/>
    </changeSet>

    <changeSet id="1490040" author="ybrigo@gmail.com">
        <createProcedure dbms="postgresql">
            create or replace function PROCESS_LOG_DATA_SEGMENT_NEXT_RANGE(P_INSTANCE_ID uuid, P_CREATED_AT timestamp, P_SEGMENT_ID bigint, P_DATA_LEN int)
            returns int4range as $$
            declare
                R_START int;
            begin
                select coalesce(max(upper(SEGMENT_RANGE)), 0) into R_START
                from PROCESS_LOG_DATA
                where
                    INSTANCE_ID = P_INSTANCE_ID and INSTANCE_CREATED_AT = P_CREATED_AT and SEGMENT_ID = P_SEGMENT_ID;

                if R_START is null then
                    R_START := 0;
                end if;

                return int4range(R_START, R_START + P_DATA_LEN);
            end;
            $$ language plpgsql;
        </createProcedure>

        <createProcedure dbms="postgresql">
            create or replace function PROCESS_LOG_DATA_NEXT_RANGE(P_INSTANCE_ID uuid, P_CREATED_AT timestamp, P_DATA_LEN int)
            returns int4range as $$
            declare
            R_START int;
            begin
                select coalesce(max(upper(LOG_RANGE)), 0) into R_START
                from PROCESS_LOG_DATA
                where
                    INSTANCE_ID = P_INSTANCE_ID and INSTANCE_CREATED_AT = P_CREATED_AT;

                if R_START is null then
                    R_START := 0;
                end if;

                return int4range(R_START, R_START + P_DATA_LEN);
            end;
            $$ language plpgsql;
        </createProcedure>
    </changeSet>

    <changeSet id="1490050" author="ybrigo@gmail.com">
        <createProcedure dbms="postgresql">
            create or replace function PROCESS_LOG_DATA_SEGMENT_LAST_N_BYTES(P_INSTANCE_ID uuid, P_CREATED_AT timestamp, P_SEGMENT_ID bigint, P_DATA_LEN int)
            returns int4range as $$
            declare
                R_START int;
            begin
                select coalesce(max(upper(SEGMENT_RANGE)), 0) into R_START
                from PROCESS_LOG_DATA
                where
                    INSTANCE_ID = P_INSTANCE_ID and INSTANCE_CREATED_AT = P_CREATED_AT and SEGMENT_ID = P_SEGMENT_ID;

                if R_START is null then
                    R_START := 0;
                end if;

                return int4range(R_START - P_DATA_LEN, R_START);
            end;
            $$ language plpgsql;
        </createProcedure>
    </changeSet>

    <changeSet id="1490060" author="ybrigo@gmail.com">
        <createProcedure dbms="postgresql">
            create or replace function NEW_PROCESS_LOG_SEGMENT(P_INSTANCE_ID uuid, P_CREATED_AT timestamp, P_CORRELATION_ID uuid, P_NAME varchar)
                returns bigint as $$
            declare
                O_SEGMENT_ID int;
            begin
            loop
                select SEGMENT_ID
                into O_SEGMENT_ID
                from PROCESS_LOG_SEGMENT
                where
                    INSTANCE_ID = P_INSTANCE_ID
                    and INSTANCE_CREATED_AT = P_CREATED_AT
                    and CORRELATION_ID = P_CORRELATION_ID
                    and SEGMENT_NAME = P_NAME;

                if FOUND then
                    return O_SEGMENT_ID;
                end if;

                insert into process_log_segment (instance_id, instance_created_at, correlation_id, segment_name, segment_ts)
                values (P_INSTANCE_ID, P_CREATED_AT, P_CORRELATION_ID, P_NAME, current_timestamp)
                on conflict do nothing
                returning process_log_segment.segment_id
                into O_SEGMENT_ID;

                if FOUND then
                    return O_SEGMENT_ID;
                end if;
            end loop;
            end;
            $$ language plpgsql;
        </createProcedure>
    </changeSet>

</databaseChangeLog>
